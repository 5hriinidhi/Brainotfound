/**
 * A minimal Writable-like interface that SilenceFiller can pipe to.
 * This matches the subset of Node.js Writable that we need.
 */
export interface PipeDestination {
    write(chunk: Uint8Array): boolean;
    end?(): void;
    on?(event: "drain", listener: () => void): this;
    once?(event: "drain", listener: () => void): this;
    removeListener?(event: "drain", listener: () => void): this;
}
type EventListener = (...args: unknown[]) => void;
/**
 * SilenceFiller is a pipeable stream that intersperses incoming audio data
 * with bytes of silence. This is important in some cases to keep an audio
 * stream "alive". Audio players, such as ffmpeg, can interpret inactivity as
 * meaning the stream is ended, or disconnected.
 *
 * This implementation does not depend on Node.js built-ins and can work in
 * any JavaScript environment, while still being pipeable to Node.js streams.
 *
 * @example
 * ```typescript
 * import { SilenceFiller } from 'hume';
 *
 * const BYTES_PER_SAMPLE = 2; // 16-bit samples
 * const SAMPLE_RATE = 48000;
 * const BUFFER_SIZE = Math.floor(SAMPLE_RATE * 0.1 * BYTES_PER_SAMPLE); // 100ms buffer
 * const silenceFiller = new SilenceFiller(BUFFER_SIZE, SAMPLE_RATE, BYTES_PER_SAMPLE, 10);
 *
 * // Pipe silence filler output to audio player stdin
 * silenceFiller.pipe(audioPlayer.stdin);
 *
 * // Handle pipe errors
 * silenceFiller.on('error', (err) => {
 *   console.error("SilenceFiller error:", err);
 * });
 *
 * // Write audio data as it arrives
 * silenceFiller.writeAudio(audioBuffer);
 *
 * // End the stream when done
 * await silenceFiller.endStream();
 * ```
 */
export declare class SilenceFiller {
    private unclockedSilenceFiller;
    private isStarted;
    private pushIntervalId;
    private bytesPerSample;
    private pushIntervalMs;
    private destination;
    private eventListeners;
    private ended;
    /**
     * Creates a new SilenceFiller instance.
     *
     * @param pushIntervalMs - The interval in milliseconds for pushing audio data (default: 5ms).
     * @param sampleRate - The sample rate of the audio (e.g., 48000).
     * @param bytesPerSample - The number of bytes per audio sample (e.g., 2 for 16-bit).
     * @param bufferSize - How much to 'prebuffer'. If you set this too low there
     * is a chance that playback will stutter, but if you set it too high
     * playback will take longer to start.
     */
    constructor(pushIntervalMs?: number, sampleRate?: number, bytesPerSample?: number, bufferSize?: number);
    /**
     * Pipes the output of this SilenceFiller to a writable destination.
     *
     * @param destination - The destination to pipe to (e.g., a Node.js Writable stream).
     * @returns The destination, for chaining.
     */
    pipe<T extends PipeDestination>(destination: T): T;
    /**
     * Registers an event listener.
     *
     * @param event - The event name ('error', 'end').
     * @param listener - The listener function.
     * @returns This instance, for chaining.
     */
    on(event: string, listener: EventListener): this;
    /**
     * Registers a one-time event listener.
     *
     * @param event - The event name ('error', 'end').
     * @param listener - The listener function.
     * @returns This instance, for chaining.
     */
    once(event: string, listener: EventListener): this;
    /**
     * Removes an event listener.
     *
     * @param event - The event name.
     * @param listener - The listener function to remove.
     * @returns This instance, for chaining.
     */
    off(event: string, listener: EventListener): this;
    /**
     * Emits an event to all registered listeners.
     *
     * @param event - The event name.
     * @param args - Arguments to pass to listeners.
     */
    private emit;
    /**
     * Writes audio data to the silence filler.
     *
     * @param audioBuffer - The audio buffer to write (Uint8Array or Buffer).
     */
    writeAudio(audioBuffer: Uint8Array): void;
    private startPushInterval;
    private pushData;
    /**
     * Ends the stream and drains all remaining audio data.
     *
     * @returns A promise that resolves when the stream has ended.
     */
    endStream(): Promise<void>;
}
/**
 * Does the actual calculation of how interspersing audio with silence
 * is "pure" in the sense that it does not rely on the system clock.
 * It's up to the caller to provide timestamps.
 *
 * @internal
 */
export declare class UnclockedSilenceFiller {
    private audioQueue;
    private totalBufferedBytes;
    private startTimestamp;
    private totalBytesSent;
    donePrebuffering: boolean;
    private bufferSize;
    private sampleRate;
    private bytesPerSample;
    constructor(bufferSize: number, sampleRate: number, bytesPerSample: number);
    writeAudio(audioBuffer: Uint8Array, timestamp: number): void;
    readAudio(timestamp: number): Uint8Array | null;
}
export {};
